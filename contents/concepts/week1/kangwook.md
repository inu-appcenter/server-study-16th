# Spring은 무엇일까요? 또, Spring과 SpringBoot의 주요한 차이점은 무엇일까요?

# 📌 Spring은 무엇일까요?

우리가 보통 Spring이라고 하면 간단하게,

자바로 만들어진 웹 어플리케이션을 편하게 개발할 수 있도록 도와주는 프레임워크라고 알고 있다.

그렇지만 정확히 스프링의 특징을 한 문장으로  정의하라고 하면, 다음과 같다.

```
자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 프레임워크
```

사실, 정의를 봐도 스프링이 무엇인지 한번에 감이 오지는 않는다. 하지만 이 정의에는 스프링의 중요한 특징이 잘 담겨있어, 이 한 문장을 세세하게 뜯어 살펴보자.

## 1-1. 애플리케이션 프레임워크

일반적으로 프레임워크라 하면, 특정 업무 분야나 한 가지 기술에 특화된 목표를 가지고 만들어진다.

예를 들면, 웹 계층을 MVC구조로 손쉽게 만들 수 있게 한다거나, 간단한 설정만으로 관계형 DB와 자바 객체를 매핑해주는 ORM 프레임워크 같은 것들이다.

그래서 프레임워크는 애플리케이션의 특정 계층에서 주로 동작하는 한 가지 기술에 집중한다.

하지만 스프링은 이와 다르게 애플리케이션 프레임워크라는 특징을 갖고 있다.

```
특정 계층이나, 기술, 업무 분야에 국한되지 않고, 애플리케이션의 전 영역을 포괄하는 범용적인 프레임워크를 말한다.
```

즉, 애플리케이션 개발의 전 과정을 빠르고 편리하게 진행하는데 일차적인 목표를 두는 프레임워크이다.

우리가 스프링을 스프링 MVC 프레임워크 또는 JDBC/ORM 지원 프레임워크라고 생각하는 것은 스프링이 다루는 일부 영역만 봤기 때문이다. 

그렇다고 단지, 여러 계층의 다양한 기술을 한데 모아뒀기 떄문에 애플리케이션 프레임워크라고 불리는 건 또 아니다.

애플리케이션의 전 영역을 관통하는 일관된 프로그래밍 모델과 핵심 기술을 바탕으로, 각 분야의 특성에 맞는 필요를 채워주고 있기 때문에 애플리케이션 프레임워크라고 불린다.

## 1-2. 경량급

스프링 정의의 다음 항목은 경량급(lightweight)이다.

스프링이 경량급이라는 건 스프링 자체가 아주 가볍다거나 작은 규모의 코드로 이뤄졌다는 뜻은 아니다.

오히려 스프링은 20여 개의 모듈로 세분화되고 수 십만 라인에 달하는 코드를 가진 매우 복잡하고 방대한 규모의 프레임워크이다.

그럼에도 스프링이 가볍다고 하는 이유는 무엇일까?

그것은, 불필요하게 무겁지 않다는 의미로,

스프링이 처음 등장하던 시절의 자바 주류 기술이었던 EJB 같은 과도한 엔지니어링이 적용된 기술과 스프링을 대비시켜 설명하려고 사용했던 표현이다.

EJB는 동작하기 위해, 툴의 도움 없이는 다루기 힘든 난해한 설정파일 구조와 까다로운 패키징 등으로 인한 부담떄문에 코드가 무겁고 복잡하게 만들어졌다.

그에 반해, 스프링은 코드는 더 단순하고 개발 과정은 편리하면서도 EJB에서 불편했던 고급 기능을 손쉽게 사용할 수 있다는 점에서 경량급이라는 의미가 붙었다.

요약하자면, 지원하는 기술 수준은 비슷하더라도, 그것을 훨씬 빠르고 간편하게 작성하게 해줌으로써,  생산성과 품질 면에서 유리하다는 것이 경량급이라는 말로 표현되는 스프링의 특징이다.

## 1-3. 자바 엔터프라이즈 개발을 편하게 해주는

기존에 등장했던 대부분의 자바 엔터프라이즈 기술과 프레임워크는 저마다 개발을 편하게 해준다고 주장하고 있다.

EJB의 불편함 때문에 스프링이 탄생했는데, 그런 EJB조차도 처음 등장 했을 때, 이러한 문구를 사용했다.

하지만, 스프링은 EJB가 궁극적으로 이루고자 했던 목적을 제대로 실현한 프레임워크이다.

EJB와의 차이점은 스프링은 엔터프라이즈 개발을 편하게 해준다라는 동일한 목적을 가졌지만, 그 과정에서 또 다른 불편함을 추가하지 않아도 되게 만들었기 때문에 가능한 일이다.

개발자들이 스프링이라는 프레임워크가 제공하는 기술이 아닌, 자신이 작성하는 로직에 더 집중할 수 있게 해준다. 

따라서 초기에 스프링의 기본 설정과 적용 기술만 준비해두면, 이후로는 스프링과 관련된 코드에 대해 신경을 쓸 일이 없다.

## 1-4. 오픈소스

오픈소스란 말 그대로 소스가 모두에게 공개되고, 특별한 라이선스를 취득할 필요 없이 얼마든지 자유롭게 이용해도 된다는 뜻이다.

하지만, 오픈소스에도 장단점은 있다.

오픈소스의 장점은 공개된 커뮤니티의 공간 안에서 투명한 방식으로 개발되기 때문에, 매우 빠르고 유연한 개발이 가능하다.

이 말은 즉, 사용자는 소스 코드의 품질과 기능을 얼마든지 검증하고 분석할 수 있고, 피드백이 그만큼 빨리 전달되고 반영된다.

잠재적인 버그나 문제점이 빠르게 발견될 수 있다.

오픈소스의 단점은 지속적이고 안정적인 개발이 계속될 지가 불확실하다는 것이다. 

상당 수의 오픈소스 제품은 핵심 개발자의 여가 시간을 이용해, 일종의 취미 활동으로 만들어진다.

그런데 개인적인 사정으로 인해 개발을 진행할 수 없거나 버그가 수정되기까지 몇 년 씩 걸리면, 최악의 상황까지 갈 수 있다.

스프링 같은 엔터프라이즈 시스템의 개발에 사용되는 프레임워크는 더욱 치명적일 수 있다. 

그래서 사용자들에게 지속적인 신뢰를 줄 수 있도록 개발을 책임지고 진행할 수 있는 전문 기업을 만들었다.

# 📌 Spring은 어떤 구성 요소를 포함하고 있나요?

![image](https://github.com/inu-appcenter/basic-study-16th/assets/62889359/5bd1d95f-1432-4205-b103-fdee71c2f43b)

이 그림은 스프링 프레임워크의 모듈 아키텍쳐 이미지이다.

## Core Container

|  | 모듈/아티팩트 | 사용 |
| --- | --- | --- |
| Core | spring-core | 다른 스프링 모듈이 사용하는 유틸리티 |
| Beans | spring-beans | 스프링 빈 지원, 의존성 주입 제공,빈 팩토리(Bean Factory) 구현 포함 |
| Context | spring-context-surpport | 빈 팩토리를 상속하는 애플리케이션 컨텍스트를 구현하고, 리소스 로드 및 국제화 지원 제공 |
| SpEL | spring-expression(Spring Expression Language) | EL(표현 언어) 확장하고 빈 속성 및 접근, 처리를 위한 언어 제공 |

**Application Context(애플리케이션 컨텍스트)?**

: 애플리케이션 전반에 걸쳐 모든 구성요소의 제어 작업을 담당하는 IoC 엔진, 스프링 컨테이너라고 부른다.

## AOP, Aspect and Instrumentation

|  | 모듈/ 아티팩트 | 사용 |
| --- | --- | --- |
| AOP | spring-aop | AOP에 대한 기본적인 기능 제공 |
| Aspect | spring-aspects | AspectJ AOP를 사용할 때 필요한 모듈 |
| Instrument | spring-instrument | 특정 애플리케이션 서버에서 사용할 클래스 계측 지원 및 클래스 로더 구현 제공 |

## Messaging

 Message, MessageChannel, MessageHandler 등의 스프링 통합 프로젝트를 포함하고 있으며 메세지 기반 애플리케이션을 구축하는 역할

## Data Access / intergration

|  | 모듈/아티팩트 | 사용 |
| --- | --- | --- |
| JDBC(Java Database Connectivity) | spring-jdbc | - JDBC 추상화 제공- Java JDBC 프로그래밍을 쉽게 할 수 있도록 제공하는 모듈 |
| ORM(Object Relational Mapping) | spring-orm | - JPA, JDO(Java Data Objects), Hibernate와 같은 ORM API를 위한 통합 레이어 제공- 간단한 선언적 트랜잭션 관리 기능을 비롯한 Spring이 제공하는 다른 모든 기능을  O/R 매핑 프레임워크로 사용할 수 있게 함 |
| OXM(Object XML Mapping) | spring-oxm | - JAXB , XMLBeans 등과 같은 객체/XML 매핑의 추상화 계층을 제공 |
| JMS(Java Message Service) | spring-jms | - 메세지 생성 및 사용을 위한 기능 제공- 스프링 프레임워크 4.1부터 spring-messasing 모듈과 통합 제공 |
| Transactions | spring-tx | - 특수 인터페이스를 구현하는 클래스와 모든 POJO에 대하여 선언적 트랜잭션 관리 지원 |

## Web

|  | 모듈/아티팩트 | 사용 |
| --- | --- | --- |
| Web | spring-web | - 멀티파트 파일 업로드와 같은 기본 웹 기능 제공- 다른 웹 프레임워크와 통합 제공 |
| Servlet | spring-webmvc | - 자체 MVC 프레임워크 제공 - Spring MVC, REST 웹 서비스 구현 포함 |
| WebSocket | spring-websocket | - 웹 소켓 지원 |
| Portlet | spring-webmvc-portlet | - 포틀릿 환경에서 사용할 MVC 구현 제공 |

## Test

spring-test,  단위 및 통합 테스트에 대한 기본적인 기능 제공

JUnit, TensNg 이용하여 테스트 컨텍스트 프레임워크나 Mock 오브젝트 이용하여 테스트할 때 사용

# 📌 MVC 패턴은 어떤 패턴을 말할까요? 또, 이 패턴은 어떻게 동작하나요?

## MVC 패턴이란?

![image](https://github.com/inu-appcenter/basic-study-16th/assets/62889359/5f469d4c-baab-4bee-a778-4423b136fd2f)

MVC 패턴은 애플리케이션 개발을 모델, 뷰, 컨트롤러, 이 세가지 영역으로 나누어 역할을 구분하여 개발하는 디자인 패턴이다.

MVC패턴을 통해 UI 영역과 비지니스 영역으로 구분하여 더 유연하게 개발을 할 수 있다.

모델은 작업처리의 결과,즉 데이터를 의미한다.

뷰는 화면에 보이는 리소스의 역할을 하며,

컨트롤러는 모델과 뷰 간의 상호작용을 도와주는 역할을 수행하며 비지니스 로직을 호출 후 모델 데이터와 뷰 데이터를 반환한다.

MVC패턴은 크게 MVC 1 패턴과 MVC 2 패턴으로 나눌 수 있다.

## MVC 1

![image](https://github.com/inu-appcenter/server-study-16th/assets/62889359/5ee75c7b-067f-4328-beb5-840d63f6d996)

MVC1 패턴의 경우 View와 Controller를 모두 JSP가 담당하는 형태를 가진다. 

즉 JSP 하나로 유저의 요청을 받고 응답을 처리하므로 구현 난이도는 쉽다.

단순한 프로젝트에는 괜찮겠지만 내용이 복잡하고 거대해질수록 이 패턴은 힘을 잃는다. 

JSP에서 MVC가 모두 이루어지다 보니, 재사용성과 가독성이 떨어지고, 유지보수에 있어 문제가 생긴다.

## MVC 2

![image](https://github.com/inu-appcenter/server-study-16th/assets/62889359/2b54a247-670e-4fbb-9b1b-bcdd68fecd96)

MVC2 패턴은 표준으로 사용되는 패턴으로,

MVC1과 다르게 모두 분리되어있다.

따라서 MVC1 패턴에서의 단점을 보완할 수 있고, 수정해야 할 부분이 있다면 M,V,C중 한 곳만 수정하면 된다.

## 스프링 MVC 패턴, 동작 구조

스프링 또한 MVC 2 패턴을 채택하는데 자세한 동작 구조는 다음과 같다.

![image](https://github.com/inu-appcenter/server-study-16th/assets/62889359/4bcc7ada-ec9e-4175-bc50-e26a4d349211)

1. 먼저 요청이 들어오면 DispatcherServlet(프론트 컨트롤러)이 제일 먼저 요청을 받는다.
2. 프론트 컨트롤러는 요청을 처리할 핸들러(컨트롤러)를 찾기 위해 핸들러 매핑을 통해 처리 가능한 핸들러를 찾는다.
3. 프론트 컨트롤러는 핸들러 어댑터를 통해 처리를 핸들러인 컨트롤러에게 전달한다.
4. 컨트롤러는 핸들러 어댑터를 통해 ModelAndView를 반환한다.
5. 프론트 컨트롤러는 뷰 리졸버를 통해 뷰를 가져오고 모델을 뷰에 랜더링 한 뒤 뷰를 반환한다.

### DispatcherServlet

![image](https://github.com/inu-appcenter/server-study-16th/assets/62889359/cc3299f6-66c1-4103-8f2e-97c9505cda14)

HttpServlet을 상속받은 DispatcherServlet은

서블릿의 생명주기와 비슷하게 흘러간다.

따라서 요청에 걸맞는 컨트롤러를 가져오는 과정은 위 그림과 같다.

# 📌 Spring과 SpringBoot의 주요한 차이점은 무엇일까요?

## 스프링부트란?

스프링의 문제점을 해결해 주기 위해 개발된 스프링의 프레임워크로,  개발자들이 더 쉽고 빠르게 스프링 애플리케이션을 개발하도록 도와주기 위해 개발되었다.

## 스프링부트의 특징(차이점)?

### 간결한 설정

스프링은 개발자들이 애플리케이션 컨텍스트 설정, 빈 정의, 다양한 컴포넌트 구성 등을 위해 많은 설정 코드를 작성해야 한다.

스프링부트는 번거로운 XML 설정이 필요하지 않고, 기본적인 설정을 자동으로 처리하여, 설정으로 인한 불편 사항을 해소해 개발에만 집중할 수 있다.

### 내장 서버

스프링 부트는 내장된 서버(내장 Tomcat, Jetty, Undertow)를 제공하여 별도의 서버 설정 없이 애플리케이션을 실행할 수 있다.

**내장톰캣을 사용하는 스프링부트 애플리케이션 실행**

- build된 스프링부트 애플리케이션 jar, war 를 java 명령어로 실행한다.

**외장톰캣을 사용하는 스프링 애플리케이션 실행**

- tomcat을 설치한다.
- tomcat 설정 파일을 구성한다.
- tomcat webapp 디렉토리에 build된 스프링 애플리케이션 war 파일을 포함시켜준다.
- tomcat을 실행해준다.

### 의존성 관리 최소화

기존 스프링에서는 라이브러리를 사용할 때 xml 파일에 버전을 명시했어야 했다.

스프링부트는 의존성 관리를 용이하게 하기 위한 ‘starter’ 의존성 통합 모듈을 제공하여 mave/gradle 설정 시 버전을 따로 명시할 필요가 없어 버전 충돌로 인한 문제를 해결했다.

# 📌 Spring Framework의 주요 특징은 무엇일까요?

![image](https://github.com/inu-appcenter/server-study-16th/assets/62889359/6dfd8f13-c2c9-4997-aaea-3801e9cf610d)

스프링의 중요한 3가지 기술이면서, 특징이라 할 수 있는 것에는 IoC/DI, AOP, PSA 가 있다. 그림을 보면 POJO를 둘러싼 형태를 볼 수 있는데, 이는 **POJO 프로그래밍을 IoC/DI, AOP, PSA를 통해서 달성할 수 있음**을 의미한다.

## POJO

POJO(Plain Old Java Object): 오래된 방식의 간단한 자바 오브젝트. 쉽게 말해 특정 자바 모델이나 기능,환경, 규약, 프레임워크 등을 따르지 않은 **순수한 자바 오브젝트**를 지칭한다.

### POJO 프로그래밍이 필요한 이유

특정 환경이나 기술에 종속적이지 않으면,

- 재사용 가능하고, 확장 가능한 유연한 코드를 작성할 수 있다.
- 코드가 깔끔해지기 때문에 디버깅하기도 상대적으로 쉽다.
- 테스트 역시 단순해진다.
- **객체지향적인 설계를 제한없이 적용할 수 있다.(가장 중요한 이유)**

## IoC는 무엇인가요?

IoC(Inversion of Control): 제어의 역전이라는 의미로, 애**플리케이션 흐름의 주도권이 뒤바뀐 것을 말한다**. 쉽게 말해 객체의 생명 주기를 개발자가 관리하는 것이 아니라, 외부에서 관리하는 것을 의미한다.

외부는 바로 스프링 컨테이너를 의미하는 것으로,  스프링 컨테이너가 빈을 생성하고 관리한다. 또한 의존성을 주입을 통해 빈을 주입해준다.

이를 통해, 개발자는 비즈니스 로직에 더욱 집중 할 수 있다.

## DI는 무엇인가요?

DI(Dependency Injection)은 의존성 주입으로

Ioc를 구현하기 위해 사용되는 방법이다.

![image](https://github.com/inu-appcenter/server-study-16th/assets/62889359/e5428975-2303-4964-9111-c3e5bdab9050)

![image](https://github.com/inu-appcenter/server-study-16th/assets/62889359/adce446f-567e-471d-81aa-20d71ce1e7ff)

위 그림 처럼, 생성자를 통해 직접 객체를 생성하는 것이 아닌,  B라는 객체가 스프링 컨테이너에서 관리하는 객체라면, 이 객체를 주입하는 것이다.

### DI를 사용하는 이유?

클래스를 직접 의존하게 되면, DIP 원칙에 위배되어 변경이 생길 때마다 코드를 수정하게 되어 유지보수가 어려워지기 떄문이다.

따라서, 객체 간 의존성을 낮추어 유지 보수와 확장성을 높이기 위해 사용한다.

### DI의 방식

1. 필드 주입

![image](https://github.com/inu-appcenter/server-study-16th/assets/62889359/cfdec456-618f-4099-b897-935a09ed6044)

1. 세터(setter) 주입

![image](https://github.com/inu-appcenter/server-study-16th/assets/62889359/f8793cbe-e505-4f85-bf75-6b67e12f515f)

1. 생성자(constructor) 주입

![image](https://github.com/inu-appcenter/server-study-16th/assets/62889359/c6b65453-9a2b-4822-8b16-efb1fc9f841f)

스프링은 현재 생성자 주입 방식을 권고하고 있다.

그 이유는 다음과 같다.

1. 필드에 final 키워드를 사용할 수 있다.

세터 주입과, 필드 주입은 객체 생성 이후 스프링 컨테이너에 의해 세터 메소드가 자동으로 호출이 되는 순서로 진행이 되기 때문에 final을 사용할 수 없다.

불변 클래스는 생성된 시점의 상태를 소멸 시까지 그대로 가지고 있기 때문에 클래스의 불변성이 보장되어 빈 객체의 필드가 변할 일이 없다.

1. 순환 참조를 미리 방지할 수 있다.

생성자 주입 방식은 객체 생성 시점에 초기화를 하기 떄문에 컴파일 시 에러를 확인할 수 있고,

필드나 세터 주입 방식은 객체 생성 후 setter를 이용하기 때문에 컴파일 시에는 에러를 확인할 수 없고 메소드 실행 시점에 확인 할 수 있다.

1. 테스트에 용이하다.

스프링 컨테이너에 의존하지 않고도 의존성을 주입하여 단위 테스트할 수 있다.

## AOP는 무엇인가요?

![image](https://github.com/inu-appcenter/server-study-16th/assets/62889359/e426e53c-befc-4680-9452-1cd860661ab3)

AOP(Aspect Oriented Programming): 관점 지향 프로그래밍이라는 의미로, 어떤 로직을 기준으로 **핵심적인 관점, 공통적인 관점(부가적인 관점)으로 나누어서 보고,** 그 관점을 기준으로 모듈화하겠다는 의미이다.

간단하게 말하자면, 공통된 기능을 재사용하는 기법이라 말할 수 있다.

AOP를 함으로써 얻을 수 있는 이점은 다음과 같다.

- ***코드의 간결성 유지***
- ***객체 지향 설계 원칙에 맞는 코드 구현***
- ***코드의 재사용***

AOP는 Aspect, PointCut 등 심오한 내용이 많고(아직 적용 시켜보지도 않았고..)  스프링의 특징을 정리한 내용이니, 나중에 각 잡고 정리하도록 하겠다.

### PSA

![image](https://github.com/inu-appcenter/server-study-16th/assets/62889359/d2b8d7c7-1c84-4c6c-b3ac-013cc3a425fe)

PSA(Portable Service Abstraction): 직역하면 휴대용 서비스 추상화라는 의미이다. 서비스 추상화란 서비스의 내용을 모르더라도 해당 서비스를 이용할 수 있다는 뜻이다.

예를 들면, 우리가 JDBC Driver를 사용해 DB에 접근하지만, JDBC Driver가 어떻게 구현되어 있는지는 모르고 관심도 없다. 

실제 구현 부를 추상화 계층으로 숨기고, 핵심적인 요소만 개발자에게 제공함으로써 실제 구현 부를 몰라도 해당 서비스를 이용할 수 있도록 하는 것이다.

Portable은 휴대용, 이동이 쉬운이라는 뜻이다. 따라서 여러 서비스를 비즈니스 로직의 수정 없이 언제든지 변경할 수 있다는 것을 의미한다.

예를 들면, MySQL Driver를 사용하다가 어느순간 Oracle Driver로 변경한다고 해서 비즈니스 로직에 변화가 없다는 것이다.

이런 기능이 가능한 것은 추상화 계층이 존재하기 때문이다.

공통 인터페이스를 두어, 해당 인터페이스를 구현한 구현체를 어떤 것을 쓰든 프로젝트에 영향이 없어지는 것이다.
